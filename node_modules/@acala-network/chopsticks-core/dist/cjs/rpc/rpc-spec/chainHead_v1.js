"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    chainHead_v1_body: function() {
        return chainHead_v1_body;
    },
    chainHead_v1_call: function() {
        return chainHead_v1_call;
    },
    chainHead_v1_continue: function() {
        return chainHead_v1_continue;
    },
    chainHead_v1_follow: function() {
        return chainHead_v1_follow;
    },
    chainHead_v1_header: function() {
        return chainHead_v1_header;
    },
    chainHead_v1_stopOperation: function() {
        return chainHead_v1_stopOperation;
    },
    chainHead_v1_storage: function() {
        return chainHead_v1_storage;
    },
    chainHead_v1_unfollow: function() {
        return chainHead_v1_unfollow;
    },
    chainHead_v1_unpin: function() {
        return chainHead_v1_unpin;
    }
});
const _shared = require("../shared.js");
const _logger = require("../../logger.js");
const logger = _logger.defaultLogger.child({
    name: 'rpc-chainHead_v1'
});
const callbacks = new Map();
async function afterResponse(fn) {
    await new Promise((resolve)=>setTimeout(resolve, 0));
    fn();
}
const chainHead_v1_follow = async (context, [withRuntime], { subscribe })=>{
    const update = async (block)=>{
        logger.trace({
            hash: block.hash
        }, 'chainHead_v1_follow');
        const getNewRuntime = async ()=>{
            const [runtime, previousRuntime] = await Promise.all([
                block.runtimeVersion,
                block.parentBlock.then((b)=>b?.runtimeVersion)
            ]);
            const hasNewRuntime = runtime.implVersion !== previousRuntime?.implVersion || runtime.specVersion !== previousRuntime.specVersion;
            return hasNewRuntime ? runtime : null;
        };
        const newRuntime = withRuntime ? await getNewRuntime() : null;
        callback({
            event: 'newBlock',
            blockHash: block.hash,
            parentBlockHash: (await block.parentBlock)?.hash,
            newRuntime
        });
        callback({
            event: 'bestBlockChanged',
            bestBlockHash: block.hash
        });
        callback({
            event: 'finalized',
            finalizedBlockHashes: [
                block.hash
            ],
            prunedBlockHashes: []
        });
    };
    const id = context.chain.headState.subscribeHead(update);
    const cleanup = ()=>{
        context.chain.headState.unsubscribeHead(id);
        callbacks.delete(id);
    };
    const callback = subscribe('chainHead_v1_followEvent', id, cleanup);
    callbacks.set(id, callback);
    afterResponse(async ()=>{
        callback({
            event: 'initialized',
            finalizedBlockHashes: [
                context.chain.head.hash
            ],
            finalizedBlockRuntime: withRuntime ? await context.chain.head.runtimeVersion : null
        });
    });
    return id;
};
const chainHead_v1_unfollow = async (_, [followSubscription], { unsubscribe })=>{
    unsubscribe(followSubscription);
    return null;
};
const chainHead_v1_header = async (context, [followSubscription, hash])=>{
    if (!callbacks.has(followSubscription)) return null;
    const block = await context.chain.getBlock(hash);
    return block ? (await block.header).toHex() : null;
};
const operationStarted = (operationId)=>({
        result: 'started',
        operationId
    });
const randomId = ()=>Math.random().toString(36).substring(2);
const chainHead_v1_call = async (context, [followSubscription, hash, method, callParameters])=>{
    const operationId = randomId();
    afterResponse(async ()=>{
        const block = await context.chain.getBlock(hash);
        if (!block) {
            callbacks.get(followSubscription)?.({
                event: 'operationError',
                operationId,
                error: `Block ${hash} not found`
            });
        } else {
            try {
                const resp = await block.call(method, [
                    callParameters
                ]);
                callbacks.get(followSubscription)?.({
                    event: 'operationCallDone',
                    operationId,
                    output: resp.result
                });
            } catch (ex) {
                callbacks.get(followSubscription)?.({
                    event: 'operationError',
                    operationId,
                    error: ex.message
                });
            }
        }
    });
    return operationStarted(operationId);
};
const chainHead_v1_storage = async (context, [followSubscription, hash, items, _childTrie])=>{
    const operationId = randomId();
    afterResponse(async ()=>{
        const block = await context.chain.getBlock(hash);
        if (!block) {
            callbacks.get(followSubscription)?.({
                event: 'operationError',
                operationId,
                error: 'Block not found'
            });
            return;
        }
        const handleStorageItemRequest = async (sir)=>{
            switch(sir.type){
                case 'value':
                    {
                        const value = await block.get(sir.key);
                        if (value) {
                            callbacks.get(followSubscription)?.({
                                event: 'operationStorageItems',
                                operationId,
                                items: [
                                    {
                                        key: sir.key,
                                        value
                                    }
                                ]
                            });
                        }
                        break;
                    }
                case 'descendantsValues':
                    {
                        // TODO expose pagination
                        const pageSize = 100;
                        let startKey = '0x';
                        while(startKey){
                            const keys = await block.getKeysPaged({
                                prefix: sir.key,
                                pageSize,
                                startKey
                            });
                            startKey = keys[pageSize - 1] ?? null;
                            const items = await Promise.all(keys.map((key)=>block.get(key).then((value)=>({
                                        key,
                                        value
                                    }))));
                            callbacks.get(followSubscription)?.({
                                event: 'operationStorageItems',
                                operationId,
                                items
                            });
                            break;
                        }
                        break;
                    }
                default:
                    // TODO
                    console.warn(`Storage type not implemented ${sir.type}`);
            }
        };
        await Promise.all(items.map(handleStorageItemRequest));
        callbacks.get(followSubscription)?.({
            event: 'operationStorageDone',
            operationId
        });
    });
    return {
        ...operationStarted(operationId),
        discardedItems: 0
    };
};
const limitReached = {
    result: 'limitReached'
};
const chainHead_v1_body = async (context, [followSubscription, hash])=>{
    if (!callbacks.has(followSubscription)) return limitReached;
    const block = await context.chain.getBlock(hash);
    if (!block) {
        throw new _shared.ResponseError(-32801, 'Block not found');
    }
    const operationId = randomId();
    afterResponse(async ()=>{
        const body = await block.extrinsics;
        callbacks.get(followSubscription)?.({
            event: 'operationBodyDone',
            operationId,
            value: body
        });
    });
    return operationStarted(operationId);
};
const chainHead_v1_continue = async (_context, [_followSubscription, _operationId])=>{
    return null;
};
const chainHead_v1_stopOperation = async (_context, [_followSubscription, _operationId])=>{
    return null;
};
const chainHead_v1_unpin = async (_context, [_followSubscription, _hashOrHashes])=>{
    return null;
};
